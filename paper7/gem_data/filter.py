import json
import os
import asyncio

from llm import Model_API, modelConfig

async def is_elegant_sol(problem):
    """
    用大模型判断 llm_answer 字段是否和正确的 final_answer 相匹配，此外，解题思路要符合 hint 和 answer 的思路
    {"question": "XXX", "answer": "XXX", "final_answer": "XXX", "hint": "XXX", "img_ggb": "XXX", "llm_answer": "XXX"}
    """
    LLM_MODEL = "gpt4o" # Use a powerful model for evaluation

    prompt = f"""You are a math competition judge. Your task is to evaluate a solution generated by an AI model.
A good solution must satisfy two conditions:
1. The final answer must be correct.
2. The solution process must be elegant and follow the provided hint.

Here is the problem and the proposed solution:

**Question:**
{problem['question']}

**Ground Truth Solution:**
{problem['answer']}

**Ground Truth Final Answer:**
{problem['final_answer']}

**Hint for an elegant solution:**
{problem['hint']}

**AI-generated Solution to evaluate:**
{problem['llm_answer']}

**Evaluation:**
1.  **Correctness:** Does the final answer from the AI-generated solution match the Ground Truth Final Answer?
2.  **Elegance & Method:** Does the AI-generated solution follow the spirit of the hint and the ground truth solution's method? It doesn't have to be identical, but it should use a similar elegant approach, not a brute-force one.

Based on your evaluation, is the AI-generated solution both correct and elegant? Please answer with only "true" or "false".
"""
    model = Model_API()
    response = await model.chat(
        model=LLM_MODEL,
        text=prompt,
        max_token=200,
        returnType="text",
        history=[]
    )
    
    return response.strip().lower() == 'true'


def filter_elegant_problems(
        input_file: str="pdf_parsed/problems_amm_doubao1.5.json", 
        output_file: str="gem_data/gem_amm.json"
    ):
    
    with open(input_file, 'r', encoding='utf-8') as f:
        problems = [json.loads(line) for line in f]

    # Ensure output directory exists
    output_dir = os.path.dirname(output_file)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Track existing problems to avoid duplicates
    existing_questions = set()
    if os.path.exists(output_file):
        with open(output_file, 'r', encoding='utf-8') as f:
            for line in f:
                try:
                    existing_problem = json.loads(line)
                    existing_questions.add(existing_problem['question'])
                except json.JSONDecodeError:
                    continue # Ignore malformed lines

    elegant_problems_count = 0
    with open(output_file, 'a', encoding='utf-8') as f_out:
        for problem in problems:
            if problem['question'] in existing_questions:
                print(f"Skipping already processed question.")
                continue

            if asyncio.run(is_elegant_sol(problem)):
                f_out.write(json.dumps(problem, ensure_ascii=False) + '\n')
                elegant_problems_count += 1
                existing_questions.add(problem['question'])
    
    print(f"Found {elegant_problems_count} new elegant problems. Total elegant problems in {output_file}.")


if __name__ == "__main__":
    cur_dir = os.path.dirname(os.path.abspath(__file__))
    input_file = os.path.join(cur_dir, "pdf_parsed/problems_amm_doubao1.5.json")
    output_file = os.path.join(cur_dir, "gem_data/gem_amm.json")
    
    filter_elegant_problems(input_file=input_file, output_file=output_file)
